//<auto-generated>
#region License
//-----------------------------------------------------------------------
// <copyright>
//     Copyright matatabi-ux 2014.
// </copyright>
//-----------------------------------------------------------------------
#endregion

namespace ResponsiveNaviBarSample.Framework
{
    using Microsoft.Practices.ServiceLocation;
    using System;
    using System.Collections.Generic;
    using System.Diagnostics.CodeAnalysis;
    using System.Globalization;
    using System.Linq;
    using System.Reflection;
    using System.Text;
    using System.Threading.Tasks;

    /// <summary>
    /// モジュール格納コンテナ
    /// </summary>
    public class ModuleContainer : IServiceLocator
    {
        #region Privates

        /// <summary>
        /// コンストラクタ情報
        /// </summary>
        private readonly Dictionary<Type, ConstructorInfo> constructorInfos = new Dictionary<Type, ConstructorInfo>();

        /// <summary>
        /// 空引数
        /// </summary>
        private readonly object[] emptyArguments = new object[0];

        /// <summary>
        /// デフォルトキー値
        /// </summary>
        private readonly string defaultKey = Guid.NewGuid().ToString();

        /// <summary>
        /// ファクトリ
        /// </summary>
        private readonly Dictionary<Type, Dictionary<string, Delegate>> factories = new Dictionary<Type, Dictionary<string, Delegate>>();

        /// <summary>
        /// インスタンス登録情報
        /// </summary>
        private readonly Dictionary<Type, Dictionary<string, object>> registry = new Dictionary<Type, Dictionary<string, object>>();

        /// <summary>
        /// インタフェース登録情報
        /// </summary>
        private readonly Dictionary<Type, Type> interfaceMap = new Dictionary<Type, Type>();

        /// <summary>
        /// 排他処理用オブジェクト
        /// </summary>
        private readonly object lockObject = new object();

        /// <summary>
        /// コンテナインスタンス
        /// </summary>
        private static ModuleContainer instance;

        #endregion //Privates

        /// <summary>
        /// シングルトンインスタンス
        /// </summary>
        public static ModuleContainer Instance
        {
            get
            {
                return instance ?? (instance = new ModuleContainer());
            }
        }

        /// <summary>
        /// 指定したクラスが登録済みか判定します
        /// </summary>
        /// <typeparam name="T">指定したクラス</typeparam>
        /// <returns>登録済みの場合 true、それ以外は false</returns>
        public bool IsRegistered<T>()
        {
            var classType = typeof(T);
            return this.interfaceMap.ContainsKey(classType);
        }

        /// <summary>
        /// 指定したキーで指定したクラスが登録済みか判定します
        /// </summary>
        /// <typeparam name="T">指定したクラス</typeparam>
        /// <param name="key">キー</param>
        /// <returns>登録済みの場合 true、それ以外は false</returns>
        public bool IsRegistered<T>(string key)
        {
            var classType = typeof(T);

            if (!this.interfaceMap.ContainsKey(classType) || !this.factories.ContainsKey(classType))
            {
                return false;
            }

            return this.factories[classType].ContainsKey(key);
        }

        /// <summary>
        /// 指定したインタフェースをもつクラスをコンテナに登録します
        /// </summary>
        /// <typeparam name="TInterface">インタフェース</typeparam>
        /// <typeparam name="TClass">クラス</typeparam>
        public void Register<TInterface, TClass>()
            where TClass : class
            where TInterface : class
        {
            this.Register<TInterface, TClass>(false);
        }

        /// <summary>
        /// 指定したインタフェースをもつクラスをコンテナに登録します
        /// </summary>
        /// <typeparam name="TInterface">インタフェース</typeparam>
        /// <typeparam name="TClass">クラス</typeparam>
        /// <param name="createInstanceImmediately">直ちにインスタンス化する場合は true にします</param>
        public void Register<TInterface, TClass>(bool createInstanceImmediately)
            where TClass : class
            where TInterface : class
        {
            lock (this.lockObject)
            {
                var interfaceType = typeof(TInterface);
                var classType = typeof(TClass);

                if (!this.interfaceMap.ContainsKey(interfaceType))
                {
                    this.interfaceMap.Add(interfaceType, classType);
                    this.constructorInfos.Add(classType, GetConstructorInfo(classType));
                }

                Func<TInterface> factory = CreateInstance<TInterface>;
                this.Register(interfaceType, factory, this.defaultKey);

                if (createInstanceImmediately)
                {
                    this.GetInstance<TInterface>();
                }
            }
        }

        /// <summary>
        /// 指定したクラスをコンテナに登録します
        /// </summary>
        /// <typeparam name="TClass">登録するクラス</typeparam>
        public void Register<TClass>()
            where TClass : class
        {
            this.Register<TClass>(false);
        }

        /// <summary>
        /// 指定したキーで指定したクラスをコンテナに登録します
        /// </summary>
        /// <typeparam name="TClass">登録するクラス</typeparam>
        /// <param name="key">キー</param>
        public void Register<TClass>(string key)
            where TClass : class
        {
            this.Register<TClass>(false, key);
        }

        /// <summary>
        /// 指定したキーで指定したクラスをコンテナに登録します
        /// </summary>
        /// <typeparam name="TClass">登録するクラス</typeparam>
        /// <param name="createInstanceImmediately">直ちにインスタンス化する場合は true にします</param>
        /// <param name="key">キー</param>
        public void Register<TClass>(bool createInstanceImmediately, string key = null)
            where TClass : class
        {
            var classType = typeof(TClass);

            lock (this.lockObject)
            {
                if (!this.interfaceMap.ContainsKey(classType))
                {
                    this.interfaceMap.Add(classType, null);
                }

                if (string.IsNullOrEmpty(key))
                {
                    key = this.defaultKey;
                }

                this.constructorInfos.Add(classType, this.GetConstructorInfo(classType));
                Func<TClass> factory = CreateInstance<TClass>;
                this.Register(classType, factory, key);

                if (createInstanceImmediately)
                {
                    this.GetInstance<TClass>();
                }
            }
        }

        /// <summary>
        /// 指定したキーで指定したクラスのインスタンスを更新します
        /// </summary>
        /// <param name="moduleType">クラスの型</param>
        /// <param name="module">インスタンス/param>
        /// <param name="key">キー</param>
        public void SetInstance(Type moduleType, object module, string key)
        {
            this.SetModule(moduleType, module, key);
        }

        /// <summary>
        /// 指定したクラスのインスタンスを更新します
        /// </summary>
        /// <typeparam name="TModule">クラス</typeparam>
        /// <param name="module">インスタンス/param>
        public void SetInstance<TModule>(object module)
        {
            this.SetModule(typeof(TModule), module, this.defaultKey);
        }

        /// <summary>
        /// 指定したキーで指定したクラスのインスタンスを更新します
        /// </summary>
        /// <typeparam name="TModule">クラス</typeparam>
        /// <param name="module">インスタンス/param>
        /// <param name="key">キー</param>
        public void SetInstance<TModule>(object module, string key)
        {
            this.SetModule(typeof(TModule), module, key);
        }

        /// <summary>
        /// 指定したクラスのインスタンスをコンテナから破棄します
        /// </summary>
        /// <typeparam name="TClass">破棄するクラス</typeparam>
        public void Discard<TClass>()
            where TClass : class
        {
            this.DiscardInstance(typeof(TClass), this.defaultKey);
        }

        /// <summary>
        /// 指定したキーで指定したクラスのインスタンスをコンテナから破棄します
        /// </summary>
        /// <typeparam name="TClass">破棄するクラス</typeparam>
        /// <param name="key">キー</param>
        public void Discard<TClass>(string key)
            where TClass : class
        {
            this.DiscardInstance(typeof(TClass), key);
        }

        /// <summary>
        /// 指定したクラスのインスタンスをコンテナから破棄します
        /// </summary>
        /// <param name="moduleType">破棄するクラスの型</param>
        public void Discard(Type moduleType)
        {
            this.DiscardInstance(moduleType, this.defaultKey);
        }

        /// <summary>
        /// 指定したキーで指定したクラスのインスタンスをコンテナから破棄します
        /// </summary>
        /// <param name="moduleType">破棄するクラスの型</typeparam>
        /// <param name="key">キー</param>
        public void Discard(Type moduleType, string key)
        {
            this.DiscardInstance(moduleType, key);
        }

        #region Private Methods

        /// <summary>
        /// 指定したキーで指定したクラスをコンテナから取得します
        /// </summary>
        /// <param name="moduleType">クラスの型</param>
        /// <param name="key">キー</param>
        /// <returns>インスタンス</returns>
        private object GetModule(Type moduleType, string key)
        {
            lock (this.lockObject)
            {
                if (string.IsNullOrEmpty(key))
                {
                    key = this.defaultKey;
                }

                Dictionary<string, object> instances;

                if (!this.registry.ContainsKey(moduleType))
                {
                    instances = new Dictionary<string, object>();
                    this.registry.Add(moduleType, instances);
                }
                else
                {
                    instances = this.registry[moduleType];
                }

                if (instances.ContainsKey(key))
                {
                    return instances[key];
                }

                object instance = null;

                if (this.factories.ContainsKey(moduleType))
                {
                    if (this.factories[moduleType].ContainsKey(key))
                    {
                        instance = this.factories[moduleType][key].DynamicInvoke(null);
                    }
                    else
                    {
                        if (this.factories[moduleType].ContainsKey(defaultKey))
                        {
                            instance = this.factories[moduleType][defaultKey].DynamicInvoke(null);
                        }
                    }
                }
                instances.Add(key, instance);
                return instance;
            }
        }

        /// <summary>
        /// 指定したキーで指定したクラスをコンテナに上書き登録します
        /// </summary>
        /// <param name="moduleType">クラスの型</param>
        /// <param name="module">インスタンス</param>
        /// <param name="key">キー</param>
        private void SetModule(Type moduleType, object module, string key)
        {
            lock (this.lockObject)
            {
                if (string.IsNullOrEmpty(key))
                {
                    key = this.defaultKey;
                }

                if (!this.registry.ContainsKey(moduleType))
                {
                    Dictionary<string, object> instances = new Dictionary<string, object>();
                    instances.Add(key, module);
                    this.registry.Add(moduleType, instances);
                }
                else
                {
                    this.registry[moduleType][key] = module;
                }
            }
        }

        /// <summary>
        /// 指定したクラス、ファクトリ、キーをコンテナに登録します
        /// </summary>
        /// <typeparam name="TClass">クラス</typeparam>
        /// <param name="classType">クラスの型</param>
        /// <param name="factory">ファクトリメソッド</param>
        /// <param name="key">キー</param>
        private void Register<TClass>(Type classType, Func<TClass> factory, string key)
        {
            if (this.factories.ContainsKey(classType))
            {
                if (this.factories[classType].ContainsKey(key))
                {
                    return;
                }

                this.factories[classType].Add(key, factory);
            }
            else
            {
                var list = new Dictionary<string, Delegate> { { key, factory } };
                this.factories.Add(classType, list);
            }
        }

        /// <summary>
        /// 指定したクラスのコンストラクタ情報を取得します
        /// </summary>
        /// <param name="moduleType">クラスの型</param>
        /// <returns>コンストラクタ情報</returns>
        private ConstructorInfo GetConstructorInfo(Type serviceType)
        {
            Type resolveTo;

            if (this.interfaceMap.ContainsKey(serviceType))
            {
                resolveTo = this.interfaceMap[serviceType] ?? serviceType;
            }
            else
            {
                resolveTo = serviceType;
            }

            var constructorInfos = resolveTo.GetTypeInfo().DeclaredConstructors.Where(c => c.IsPublic).ToArray();

            if (constructorInfos.Length > 1)
            {
                return constructorInfos.FirstOrDefault(i => i.Name != ".cctor");
            }

            return constructorInfos[0];
        }

        /// <summary>
        /// 指定したクラスのインスタンスを生成します
        /// </summary>
        /// <typeparam name="TClass">クラス</typeparam>
        /// <returns>インスタンス</returns>
        private TClass CreateInstance<TClass>()
        {
            var moduleType = typeof(TClass);

            var constructor = constructorInfos.ContainsKey(moduleType)
                                  ? constructorInfos[moduleType]
                                  : GetConstructorInfo(moduleType);

            var parameterInfos = constructor.GetParameters();

            if (parameterInfos.Length == 0)
            {
                return (TClass)constructor.Invoke(emptyArguments);
            }

            var parameters = new object[parameterInfos.Length];

            foreach (var parameterInfo in parameterInfos)
            {
                parameters[parameterInfo.Position] = GetModule(parameterInfo.ParameterType, defaultKey);
            }

            return (TClass)constructor.Invoke(parameters);
        }

        /// <summary>
        /// 指定したキーで指定したクラスのインスタンスをコンテナから破棄します
        /// </summary>
        /// <param name="moduleType">クラスの型</param>
        /// <param name="key">キー</param>
        private void DiscardInstance(Type moduleType, string key)
        {
            lock (this.lockObject)
            {
                if (string.IsNullOrEmpty(key))
                {
                    key = this.defaultKey;
                }

                Dictionary<string, object> instances;

                if (this.registry.ContainsKey(moduleType))
                {
                    instances = this.registry[moduleType];
                    if (instances.ContainsKey(key))
                    {
                        instances.Remove(key);
                    }
                }
            }
        }

        #endregion //Private Methods

        #region IServiceProvider

        /// <summary>
        /// 指定したクラスのすべてのインスタンスを取得します
        /// </summary>
        /// <param name="moduleType">クラスの型</param>
        /// <returns>インスタンス</returns>
        public IEnumerable<object> GetAllInstances(Type serviceType)
        {
            lock (this.factories)
            {
                if (this.factories.ContainsKey(serviceType))
                {
                    foreach (var factory in factories[serviceType])
                    {
                        this.GetInstance(serviceType, factory.Key);
                    }
                }
            }

            if (this.registry.ContainsKey(serviceType))
            {
                return this.registry[serviceType].Values;
            }
            return new List<object>();
        }

        /// <summary>
        /// 指定したクラスのすべてのインスタンスを取得します
        /// </summary>
        /// <typeparam name="TService">クラス</typeparam>
        /// <returns>インスタンス</returns>
        public IEnumerable<TService> GetAllInstances<TService>()
        {
            var serviceType = typeof(TService);
            return this.GetAllInstances(serviceType)
                .Select(instance => (TService)instance);
        }

        /// <summary>
        /// 指定したクラスのインスタンスを取得します
        /// </summary>
        /// <param name="moduleType">クラスの型</param>
        /// <returns>インスタンス</returns>
        public object GetInstance(Type serviceType)
        {
            return this.GetModule(serviceType, defaultKey);
        }

        /// <summary>
        /// 指定したキーで指定したクラスのインスタンスを取得します
        /// </summary>
        /// <param name="moduleType">クラスの型</param>
        /// <param name="key">キー</param>
        /// <returns>インスタンス</returns>
        public object GetInstance(Type serviceType, string key)
        {
            return this.GetModule(serviceType, key);
        }

        /// <summary>
        /// 指定したクラスのインスタンスを取得します
        /// </summary>
        /// <typeparam name="TService">クラス</typeparam>
        /// <returns>インスタンス</returns>
        public TService GetInstance<TService>()
        {
            return (TService)this.GetModule(typeof(TService), this.defaultKey);
        }

        /// <summary>
        /// 指定したキーで指定したクラスのインスタンスを取得します
        /// </summary>
        /// <typeparam name="TService">クラス</typeparam>
        /// <param name="key">キー</param>
        /// <returns>インスタンス</returns>
        public TService GetInstance<TService>(string key)
        {
            return (TService)this.GetModule(typeof(TService), key);
        }

        #endregion //IServiceProvider
    }
}

